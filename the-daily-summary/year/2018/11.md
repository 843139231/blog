### 11月每日阅读总结

### 2018-11-21
* [JavaScript深入之内存空间详细图解](https://mp.weixin.qq.com/s/x4ZOYysb9XdT1grJbBMVkg)
    * 在某些时候，调用堆栈中函数调用的数量超过了调用堆栈的实际大小，浏览器会抛出一个错误终止运行
        * 通常发生在 循环、递归中。堆栈的实际大小，这个是浏览器定义的
    * 栈数据结构：
        * 之前有提到过 是 LIFO 的结构（后进先出）
    * 堆数据结构：
        * 堆数据结构是一种树状结构。它的存取数据的方式与书架和数非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书都取出来
    * 变量的存放：
        * 内存中有栈和堆，那么变量应该存放在哪里呢，堆？栈？
            * 基本类型 --> 基本类型 是保存在 栈内存 中，因为这些类型在内存中分别占用固定大小的空间，通过按值来访问。基本类型一共有6种：Undefined、Null、Boolean、Number、String、Symbol
            * 引用类型 --> 保存在 堆内存 中，因为这种值的大小不固定，因此不能把他们保存到栈内存中，但内存地址大小是固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。
            先从 栈中读取内存地址，然后再通过地址找到堆中的值。我们一般称呼为 引用访问
    * 内存空间管理
        * 分配你所需要的内存
        * 使用分配到的内存（读、写）
        * 不需要时将其释放、归还
    * 思考题：

        ```
        var a = {n: 1};
        var b = a;
        a.x = a = {n: 2};

        a.x     // 这时 a.x 的值是多少
        // undefined
        b.x     // 这时 b.x 的值是多少
        // {n:2}
        // . 运算符的优先级 同  [] ()
        // 所以先运行 a.x = {n: 2}
        // 再运行 a = {n: 2}
        ```

### 2018-11-20
* [JavaScript深入之执行上下文栈和变量对象](https://mp.weixin.qq.com/s/hZIpnkKqdQgQnK1BcrH6Nw)
    * 总所周知，在js 中 是有 变量提升一说的，在 变量 被声明前进行  使用。那么，变量 和 函数 的提升哪个优先级更高呢？
        最后的结论是， 函数 > 变量

        ```
            foo();  // foo2
            var foo = function() {
                console.log('foo1');
            }

            foo();  // foo1，foo重新赋值

            function foo() {
                console.log('foo2');
            }

            foo(); // foo1
        ```
    * 执行上下文栈
        * 因为 js 引擎创建了很多的执行上下文，所以 js 引擎也创建了 执行上下文栈 来管理执行上下文
            * 当 js 初始化的时候会向执行上下文栈压入一个全局执行上下问，并且只有当整个应用程序结束的时候，执行栈才会被清空，所以在程序结束之前，执行栈最底部永远有个 全局执行上下文
    * 函数上下文
        * 在函数上下文，用 活动对象（activation object，AO）来表示变量对象
        * 活动对象 和 变量对象的区别：
            * 变量对象（VO）是规范上或者 js 引擎上实现的，并不能在js环境中直接访问
            * 当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问
        调用函数时，会为其创建一个 Arguments 对象，并自动初始化局部变量 arguments，指代该Arguments对象。所有作为参数传入的值都会变成Arguments对象的伪数组元素
    * 执行过程
        * 进入执行上下文
            * 这个时候还没有执行代码，此时的变量对象会包括：
                * 1、函数的所有形参（only函数上下文）：没有实参，属性值设为 undefined
                * 2、函数声明：如果变量对象已经存在相同名称的属性，则完全 替换 这个属性
                * 3、变量声明：如果变量名称跟已经声明的形参活函数相同， 则变量什么不会干扰到存在的这类属性
        * 代码执行
            * 这个阶段会顺序执行代码，修改变量对象的值
    * 总结：
        * 1、全局上下文的变量对象初始化是全局对象
        * 2、函数上下文的变量对象初始化只包括Arguments对象
        * 3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明 等初始的属性值
        * 4、在代码执行阶段，会再次修改变量对象的属性值

* [求岛屿最大面积](https://leetcode-cn.com/problems/max-area-of-island/)
    * 这个目前我采用的是，深度优先算法 dfs
    * 需要解决的问题：
        * 需要标记 已经计算过的位置，避免重复计算。防止造成死循环 或 浪费资源
        * 目前的做法是 建立一个visited的复制数组，以此来防止直接更改原数据，用的是最简单的深拷贝的方法，虽然会损耗些性能，但是在维持数据的一致性上我认为是可以接受的

        ```
        function island(grid, i, j, len, k){
            if(i >= 0 && i < len && j >= 0 && j < k && grid[i][j] == 1){
                // 防止重复计算
                grid[i][j] = 0;
                // 计算四边形
                return 1 + island(grid, i+1, j, len, k) + island(grid, i-1, j, len, k) + island(grid, i, j+1, len, k) + island(grid, i, j-1, len, k);
            }
            return 0;
        }
        ```

### 2018-11-19
* [理解JavaScript 中的执行上下文和执行栈](https://mp.weixin.qq.com/s/tNl5B4uGdMkJ2bNdbbo82g)
    * 执行上下文总共有三种类型：
        * 全局执行上下文：只有一个，浏览器中的全局对象就是window对象，this指向这个全局对象
        * 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文
        * Eval 函数执行上下文：指的是运行在 eval 函数中的代码，基本很少用而且不建议使用
    * 执行栈
        * 执行栈，也叫调用栈，具有 LIFO(后进先出)结构
        * 首次运行 js 代码时，会创建一个 全局执行上下文 并push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个 新的函数执行上下文 并push到当前执行栈的栈顶
    * 执行上下文的创建
        * 创建阶段：
            * 确定 this 的值，也被成为  This Binding
                * 全局执行上下文，this 的值指向全局对象，在浏览器中 this 指向 window对象，而在 node 中指向这个文件的 module 对象
                * 函数执行上下，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显示绑定、new绑定、箭头函数等
            * LexicalEnvironment（词法环境）组件被创建
                * 环境记录：存储变量和函数声明的实际位置
                * 对外部环境的引用：可以访问其外部词法环境
            * VariableEnvironment（变量环境）组件被创建
        * 执行阶段：
            * 此阶段，完成对所有变量的分配，最后执行代码

### 2018-11-16
* 每日总结
    * element ui的 el-table 本身没有自定义扩张进行 针对每一行进行操作，本身有 标签  el-table-column  可以操作 每一列，此时如果业务需求需要针对 每一行的某个条件进行过滤，可以使用 row-class-name 或 row-style 来进行 方法控制，return出去一个 隐藏的className 或者 style，以达到我们想要的目的。
    * 其实还有另外一种做法，是在数据源上做文章。不符合规则的数据源直接  filter 掉，也是可以的，这两种方法具体采用哪种，需要根据业务需求进行选择

### 2018-11-15
* [前端安全系列之二：如何防止CSRF攻击？](https://juejin.im/post/5bc009996fb9a05d0a055192)
    * csrf
        CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
        * 防范策略
            * 同源检测
                * 在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
                    Origin Header
                    Referer Header
                * 使用Origin Header确定来源域名：
                    如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以。
                    Origin在以下两种情况下并不存在：
                        * IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同
                        * 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息
                * 使用Referer Header确定来源域名
                    新版的Referrer Policy规定了五种Referer策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。

                    Referrer Policy的策略设置成same-origin，对于同源的链接和引用，会发送Referer，referer值为Host不带Path；跨域访问则不携带Referer。例如：aaa.com引用bbb.com的资源，不会发送Referer。
                    设置Referrer Policy的方法有三种：
                        * 在CSP设置
                        * 页面头部增加meta标签
                        * a标签增加referrerpolicy属性
                        但是 攻击者可以在自己的请求中隐藏Referer。如果攻击者将自己的请求这样填写：
                            `<img src="http://bank.example/withdraw?amount=10000&for=hacker" referrerpolicy="no-referrer">`
                        那么这个请求发起的攻击将不携带Referer。
                        此外：
                            * IE6、7下使用window.location.href=url进行界面的跳转，会丢失Referer。
                            * IE6、7下使用window.open，也会缺失Referer。
                            * HTTPS页面跳转到HTTP页面，所有浏览器Referer都丢失。
                            * 点击Flash上到达另外一个网站的时候，Referer的情况就比较杂乱，不太可信。

                * 无法确认来源域名情况：
                    如果Origin和Referer都不存在，建议直接进行阻止，特别是如果没有使用随机CSRF Token（参考下方）作为第二次检查。
            * csrf token
                而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。

                Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。
                但是此方法的实现比较复杂，需要给每一个页面都写入Token。 这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏。

* [React 的今天和明天（图文版） —— 第一部分](https://juejin.im/post/5be90d825188254b0917f180)
    * React 现在有三个问题：逻辑复用、庞大的组件和 Class。逻辑复用的问题会导致你经常遇到“包装地狱”。庞大组件的原因是由于逻辑分散到了不同的生命周期中。而令人困惑的 class 无论对于人类还是机器来说都是个难题。

* 日常总结
    * 因为 axios 本身就是支持 promise 的捕捉的，所以这里 在错误的情况下  直接  return 异常出去就好。

    ```
    请求拦截器，请求发送之前做些事情
    axios.interceptors.request.use(config => {
        ... // 做想做的事
        return config
    }, error => {
        return Promise.reject(error);
    })
    响应拦截器，请求返回异常统一处理
    axios.interceptors.response.use(response => {
        ... // 做想做的事
        return response
    }, error => {
        return Promise.reject(error);
    });
    ```

    * 编写符合 cmd、amd、commonjs 规范的模块

    ```
    (function(factory){
        if(typeof exports === 'object'){
            // node/commonjs
            factory(require('document'), require('window'));
        } else if(typeof define === 'function' && define.amd){
            // amd
            define(factory(document, window));
        } else {
            // browser globals
            factory(document, window);
        }
    })(function(document, window){
        ...
        // 做想做的事
    });
    ```



### 2018-11-14
* [ES6 系列之模块加载方案](https://juejin.im/post/5bea425751882508851b45d6)
    * 模块加载规范有4种：
        * amd
        * cmd
        * commonJs
        * Es6模块
    * amd
        amd 是 requireJS在推广过程中对模块定义的规范化产出，AMD 规范，其主要内容就是定义了 define 函数该如何书写，只要按照这个规范书写模块和依赖，require.js 就能正确的进行解析

        ```
        // index.html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>require</title>
        </head>
        <body>
            <script data-main="vender/main" src="https://cdn.bootcss.com/require.js/2.3.6/require.min.js"></script>
        </body>
        </html>
        ```
        以data-main 属性来指定主程序
        
        ```
        // vender/main.js
        requirejs.config({
            paths: {
                addModule: './add',
                squareModule: './square'
            }
        });
        
        require(['addModule', 'squareModule'], function(addModule, squareModule){
            console.log(addModule.add(1, 1));
            console.log(squareModule.square(3))
        });
        ```
        require.config 导入模块是全局都可以使用的，比较适合 框架、基础包之类的文件导入
        
        ```
        // vender/multiply.js
        define(['addModule'], function(addModule) {
            'use strict';
            console.log('加载了 multiply 模块');
            console.log(addModule);
            var multiply = function(x, y){
                return x * y;
            }
        
            return {
                multiply: multiply
            }
        });
        ```
        内部其他文件可以直接导入依赖
        
        ```
        // vender/square.js
        define(['./multiply'], function(multiplyModule) {
            'use strict';
            console.log('加载了 square 模块');
            var square = function(x){
                return multiplyModule.multiply(x, x);
            }
        
            return {
                square: square
            }
        });
        ```
        局部依赖导入，其他模块如需该模块的支持，需要重新导入文件
        
        ```
        // vender/add.js
        define(function() {
            'use strict';
            console.log('加载了 add 模块');
            var add = function(x, y){
                return x + y;
            }
        
            return {
                add: add
            }
        });
        ```
        不导入任何模块
        
        ```
        // 加载了 add 模块
        // 加载了 multiply 模块
        // {add: f}
        // 加载了 square 模块
        // 2
        // 9
        ```
    * cmd
        cmd 是 seaJs在推广过程中对模块定义的规范化产出。CMD 规范，其主要内容就是描述如何定义模块，如何导入模块，如何导出模块，只要按照这个规范书写代码，sea.js就能正确的进行解析
        
        ```
        // index.html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>seaJs</title>
        </head>
        <body>
            <script src="https://cdn.bootcss.com/seajs/3.0.3/sea.js"></script>
            <script>
                seajs.use('./vender/main');
            </script>
        </body>
        </html>
        ```
        通过  seajs.use 来加载主模块
        
        ```
        // vender/main.js
        define(function(require, exports, module) {
            'use strict';
            var addModule = require('./add');
            console.log(addModule.add(1, 1));
        
            var squareModule = require('./square');
            console.log(squareModule.square(3))
        });
        ```
        通过 require 来进行导入模块
        
        ```
        // vender/add.js
        define(function(require, exports, module) {
            'use strict';
            console.log('加载了 add 模块');
            var add = function(x, y){
                return x + y;
            }
        
            module.exports = {
                add: add
            }
        });
        ```
        通过  module.exports 来进行导出模块
        
        ```
        // vender/square.js
        define(function(require, exports, module) {
            'use strict';
            console.log('加载了 square 模块');
        
            var multiplyModule = require('./multiply');
        
            var square = function(x){
                return multiplyModule.multiply(x, x);
            }
        
            module.exports = {
                square: square
            }
        });
        
        // vender/multiply.js
        define(function(require, exports, module) {
            'use strict';
            console.log('加载了 multiply 模块');
            var multiply = function(x, y){
                return x * y;
            }
        
            module.exports = {
                multiply: multiply
            }
        });
        ```
        运行结果
        
        ```
        // 加载了 add 模块
        // 2
        // 加载了 square 模块
        // 加载了 multiply 模块
        // 9
        ```
        
        * 由此可见，CDM 推崇依赖就近，AMD 推崇依赖前置。
            对于依赖的模块，AMD是提前执行，CMD是延迟执行
            对于 AMD 的这种提前加载，在技术上是比较好实现的，而对于CMD的这种，延迟执行，暂时还没有闹明白，不知道是否做了语法切割在require 之间进行切割，以一段一段的方式来进行运行
        * AMD 和 CMD 都是用于浏览器端的模块规范，而在服务端 比如node，采用的则是 CommonJs 规范
        * CommonJs 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。
            * AMD 规范 是非同步加载模块，允许指定回调函数。而node 主要用于服务端，模块文件一般都是存在于本地，所以加载起来很快，不用考虑非同步加载的方式，所以commonJs规范比较适用
            * 但是浏览器端，要用服务端加载模块，最好还是采用非同步模块，因此浏览器端一般采用 AMD 规范
    * Es6模块
        通过script 加载主模块，指定 type 为 module 告诉浏览器这是es6 模块加载
        
        ```
        // index.html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>es6 module</title>
        </head>
        <body>
            <script src="./vender/main.js" type="module"></script>
        </body>
        </html>
        ```
        通过  import   加载模块
        
        ```
        // vender/main.js
        import { add } from './add.js';
        
        console.log( add(1, 1) );
        
        import { square } from './square.js';
        
        console.log( square(3) );
        ```
        
        通过 export 导出模块
        
        ```
        // vender/add.js
        console.log('加载了 add 模块');
        
        var add = function(x, y){
            return x + y;
        }
        
        export {
            add
        }

        // vender/square.js
        console.log('加载了 square 模块');
        
        import { multiply } from './multiply.js';
        
        var square = function(x){
            return multiply(x, x);
        }
        
        export {
            square
        }

        // vender/multiply.js
        console.log('加载了 multiply 模块');
        
        var multiply = function(x, y){
            return x * y;
        }
        
        export {
            multiply
        }
        ```
        运行结果
        
        ```
        // 加载了 add 模块
        // 加载了 multiply 模块
        // 加载了 square 模块
        // 2
        // 9
        ```
        由此可见，es6的模块加载 跟 require 加载一样，都是 非同步加载模式，在所有的依赖加载完成后才会去进行执行

* [前端安全系列（一）：如何防止XSS攻击？](https://tech.meituan.com/fe_security.html)
    * 我们很难完全避免xss，但是我们通过 减少漏洞的产生
        * 利用模板引擎：开启模板引擎自带的html转义功能
        * 避免内联事件：尽量不要 onLoad=“onload(‘{{data}}’)" 这种拼接内联事件的写法。在js通过 addEventlistener 的事件绑定会更安全
        * 避免拼接 html：最好采用  createElement、setAttribute 方法实现，或者 采用 比较成熟的渲染框架  如 Vue/React等
        * 时刻保持警惕：在插入位置为dom属性、链接等位置时，要打起精神，严加防范
        * 增加攻击难度、降低攻击后果：通过csp、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果
        * 主动检测和发现：可使用xss攻击字符串和自动扫描工具寻找潜在的xss漏洞
    * 在css、html 中 使用webpack中定义的别名 ~ 需要加上这个符号，告诉webpack 我使用的是别名
    

### 2018-11-13
* [谈一谈flex布局使用中碰到的一些问题](https://www.jqhtml.com/18730.html)
    * flex单值、双值、三值的赋值规则是怎么样的
    * flex-grow 定义弹性项目的放大比列，可以接受数字（小数也可以），不接受负值，默认值是 0 。这个值如果为 0 就意味着即使容器内还存在剩余空间，弹性项目也不会放大。
    * flex-shrink 定义弹性项目的收缩比例，同样接受数字（小数也可以），不接受负值，默认值是 1 。如果一个弹性项目的 flex-shrink 设为 0 而其他弹性项目的 flex-shrink 值为 1 ，则当弹性容器空间不足时，该弹性项目不会被压缩，而其他的弹性项目会被等比例压缩。
    * flex-basis 定义在分配容器内空间之前，弹性项目占据的主轴空间（不一定是宽度，因为主轴方向可以是纵向的），默认值是 auto 。如果对弹性项目同时设置 flex-basis 和 width ， width 会被忽略。还要注意当主轴是横向的时候，如果设定了 max-width 或 min-width 会限制弹性项目的宽度。
    * 单值情况下：
        * 一个无单位的数字：它会被当作 flex-grow 的值，flex-shrink 为 1 ，flex-basis 为 0%。
        * 一个有效的宽度值：它会被当作 flex-basis 的值，flex-shrink 和 flex-grow 都是 1 。
        * 关键字：比如 auto，none 这两个下文会讲。
    * 双值情况下：
        * 第一个值必须是无单位的数字，它会作为 flex-grow 的值；第二个值可以是：
            * 一个无单位的数字：它会被当作 flex-shrink 的值，而flex-basis 的值就是 0% 。
            * 一个有效的宽度值：它会被当作 flex-basis 的值，flex-shrink 的取值就是 1 。
    * 三值情况下：
        * 第一个和第二个值必须是无单位的数，分别作为 flex-grow，flex-shrink，flex-basis 的值；第三个值可以是有效的宽度值，也可以是 auto 。

    * flex: 0，flex: 1，flex: auto，flex: none，flex: 0%的区别是什么？
        * flex: 0 是 flex: 0 1 0%  的简写
        * flex: none 是 flex: 0 0 auto 的简写
        * flex: 1 是 flex: 1 1 0% 的简写
        * flex: auto 是 flex: 1 1 auto 的简写
        * flex: 0% 是 flex: 1 1 0% 的简写

### 2018-11-12

* 日常总结
    * 当我们需要进行中文排序的时候可以使用
    `['向第三方', '爱仕达多'].sort((a, b) => a.localeCompare(b, 'zh')); // 排序格式 数字 > 拼音 > 字母`
* [JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)
    * 函数式编程中的  of 方法，并不是用来避免使用 new 关键字的，而是用来把值放到默认最小化上下文中的

        ```
        let Container = function(x){
            this.__value = x;
        }
        Container.of = x => new Container(x);
    
        Container.prototype.map = function(f){
            return Container.of(f(this.__value))
        }
        ```
    * 在日常的开发中，我们可以使用 curry 来进行 多参数的函数封装

        ```
        // 仿lodash的curry
        const curry = function(fx){
            var arity = fx.length;
    
            return function f1() {
                var args = Array.prototype.slice.call(arguments, 0);
                if (args.length >= arity) {
                    return fx.apply(null, args);
                } else {
                    var f2 = function f2() {
                        var args2 = Array.prototype.slice.call(arguments, 0);
                        return f1.apply(null, args.concat(args2)); 
                    }
                    f2.toString = function() {
                        return inspectFn(fx) + inspectArgs(args);
                    }
                    return f2;
                }
            };
        }
        ```
* [ES2018（ES9） 带来的重大新特性](https://juejin.im/entry/5be2243451882516c713cda4)
    * defineProperty，可以在一个对象上定义一个新属性，或者修改一个现有属性，并返回这个现有对象。vue2.x 主要是它来进行 数据双向数据绑定、依赖搜集，Object.defineProperty(obj, key, {****}) 
    * defineProperty 中，vlaue 和 get 方法不可同时出现
        * 所以在这里就引发出了一个问题，value的存储和获取的问题。需要去做额外的开销来进行存储。也可以理解为一个数据仓库，需要缓存  value、get方法、set方法
        * 解决方案：
        * 使用 Object.getOwnPropertyDescriptor 来进行读取默认配置

        ```
        (function(){
            var root = this;
            function watch(obj, key, func){
                // 读取配置
                let property = Object.getOwnPropertyDescriptor(obj, key);
                console.log(property);
    
                let value
    
                // 如果属性值不能修改，直接返回
                if(property && property.configurable === false){ return }
    
                let getter = property && property.get,
                    setter = property && property.set;
                
                if(!getter || setter){
                    value = property[key];
                }
    
                Object.defineProperty(obj, key, {
                    get(){
                        let val = getter ? getter.call(obj) : value;
                        return val
                    },
                    set(newValue){
                        let val = getter ? getter.call(obj) : value;
                        // 如果值没有改变，或者 自身不等于自身 直接返回
                        if(val === newValue || (newValue !== newValue && val !== val)){ return }
    
                        setter ? setter.call(obj, newValue) : value = newValue;
                        func(newValue);
                    }
                });
    
                if(value) obj[key] = value;
            }
            this.watch = watch;
        })();
    
        var obj = { name: 'the lonelt' };
        watch(obj, 'name', (value) => {
            console.log(value); // special3961
        });
        watch(obj, 'name', (value) => {
            console.log(value); // special3961
        });
        obj.name = 'special3961';
        ```

    * defineProperty 是 es5的方法，es6提供了更加优雅的 proxy，可以重定义更多的行为

        ```
        let proxy = new Proxy({}, {
            get(obj, prop){
                console.log('设置 get 操作', '    操作源: '+JSON.stringify(obj), '    操作者：'+prop); // 设置 set 操作     操作源: {}     操作者：time     值：35
                return obj[prop]
            },
            set(obj, prop, value){
                console.log('设置 set 操作', '    操作源: '+JSON.stringify(obj), '    操作者：'+prop, '    值：'+value); // 设置 get 操作     操作源: {"time":35}     操作者：time
                obj[prop] = value;
            }
        });
    
        proxy.time = 35;
    
        console.log(proxy.time);
        ```
        
        * 除此之外还可以  拦截  apply、call方法、使用 has方法 拦截 in 操作、ownKeys 方法 拦截对象自身属性的读取操作
        * 不过虽然  proxy 很好用，但是 它最大的问题在于 浏览器支持度不够，而且很多效果无法使用 poilyfill来弥补
    * 使用 defineProperty 和 proxy 还是有很大区别的， 当使用 defineProperty，我们修改原来的obj对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截。

        ```
        (function(){
            var root = this;
            function watchProxy(obj, key, func){
                let proxt = new Proxy(obj, {
                    get(target, prop){
                        return target[prop]
                    },
                    set(target, prop, value){
                        target[prop] = value;
                        func(value);
                    }
                });
    
                return proxt;
            }
            this.watchProxy = watchProxy;
        })();
    
        var obj1 = { name: 'the lonelt' };
        obj1 = watchProxy(obj1, 'name', (value) => {
            console.log(value); // special3961
        });
        obj1 = watchProxy(obj1, 'name', (value) => {
            console.log(value); // special3961
        });
        obj1.name = 'special3961';
    
        var obj2 = { name: 'the lonelt' };
        var obj3 = watchProxy(obj2, 'name', (value) => {
            console.log(value); // special3961
        });
        obj3.name = 'special3961';
        console.log(obj3); // Proxy {name: "special3961"}
        console.log('obj3.name: '+obj3.name, '    obj2.name: '+obj2.name); // obj3.name: special3961     obj2.name: special3961
        ```
        由此可见，当我们修改源对象的时候，会把2个对象的值都进行了更改，但是我们设置的  事件拦截，修改源对象的时候并不会触发，只有修改 proxy的实例才会触发

    * 可以使用   Object.create(null); 来创建一个  纯对象，绝对的干净
    * JSON.stringify 不仅可以简单的将对象转化为字符串，还可以格式化json输出        JSON.stringify(obj, null, 4)
    * 数组去重，es6 最快的方法    arr => […new Set(arr)];![image](../../../images/3F5058F4-9E20-41C1-8EE1-5B1DE783A063.png)
    * 平铺数组 可以使用  … 展开符 + concat 方法

        ```
        const arr = [11, [22, 33], [44, 55], 66];
        console.log([].concat(...arr)); //=> [11, 22, 33, 44, 55, 66]
    
        function flattenArray(arr){
            let flatten = [].concat(...arr);
            return flatten.some((item) => Array.isArray(item)) ? flattenArray(flatten) : flatten;
        }
    
        let array = [11, [111, [10, 30, [50, 9, 20]]], [22, 33], [44, [55, 66, [77, [88]], 99]]];
        let numberList = flattenArray(array);
        console.log(numberList); // [11, 111, 10, 30, 50, 9, 20, 22, 33, 44, 55, 66, 77, 88, 99]
        ```

        * 不过这种方法 仅仅适合于二维数字，但是可以通过递归 平铺任意维度的嵌套数组


