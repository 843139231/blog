### 11月每日阅读总结

### 2018-11-15
* [前端安全系列之二：如何防止CSRF攻击？](https://juejin.im/post/5bc009996fb9a05d0a055192)
    * csrf
        CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
        * 防范策略
            * 同源检测
                * 在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
                    Origin Header
                    Referer Header
                * 使用Origin Header确定来源域名：
                    如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以。
                    Origin在以下两种情况下并不存在：
                        * IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同
                        * 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息
                * 使用Referer Header确定来源域名
                    新版的Referrer Policy规定了五种Referer策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。

                    Referrer Policy的策略设置成same-origin，对于同源的链接和引用，会发送Referer，referer值为Host不带Path；跨域访问则不携带Referer。例如：aaa.com引用bbb.com的资源，不会发送Referer。
                    设置Referrer Policy的方法有三种：
                        * 在CSP设置
                        * 页面头部增加meta标签
                        * a标签增加referrerpolicy属性
                        但是 攻击者可以在自己的请求中隐藏Referer。如果攻击者将自己的请求这样填写：
                            `<img src="http://bank.example/withdraw?amount=10000&for=hacker" referrerpolicy="no-referrer">`
                        那么这个请求发起的攻击将不携带Referer。
                        此外：
                            * IE6、7下使用window.location.href=url进行界面的跳转，会丢失Referer。
                            * IE6、7下使用window.open，也会缺失Referer。
                            * HTTPS页面跳转到HTTP页面，所有浏览器Referer都丢失。
                            * 点击Flash上到达另外一个网站的时候，Referer的情况就比较杂乱，不太可信。

                * 无法确认来源域名情况：
                    如果Origin和Referer都不存在，建议直接进行阻止，特别是如果没有使用随机CSRF Token（参考下方）作为第二次检查。
            * csrf token
                而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。

                Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。
                但是此方法的实现比较复杂，需要给每一个页面都写入Token。 这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏。
* [React 的今天和明天（图文版） —— 第一部分](https://juejin.im/post/5be90d825188254b0917f180)
    React 现在有三个问题：逻辑复用、庞大的组件和 Class。逻辑复用的问题会导致你经常遇到“包装地狱”。庞大组件的原因是由于逻辑分散到了不同的生命周期中。而令人困惑的 class 无论对于人类还是机器来说都是个难题。



### 2018-11-14
* [ES6 系列之模块加载方案](https://juejin.im/post/5bea425751882508851b45d6)
    * 模块加载规范有4种：
        * amd
        * cmd
        * commonJs
        * Es6模块
    * amd
        amd 是 requireJS在推广过程中对模块定义的规范化产出，AMD 规范，其主要内容就是定义了 define 函数该如何书写，只要按照这个规范书写模块和依赖，require.js 就能正确的进行解析

        ```
        // index.html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>require</title>
        </head>
        <body>
            <script data-main="vender/main" src="https://cdn.bootcss.com/require.js/2.3.6/require.min.js"></script>
        </body>
        </html>
        ```
        以data-main 属性来指定主程序
        
        ```
        // vender/main.js
        requirejs.config({
            paths: {
                addModule: './add',
                squareModule: './square'
            }
        });
        
        require(['addModule', 'squareModule'], function(addModule, squareModule){
            console.log(addModule.add(1, 1));
            console.log(squareModule.square(3))
        });
        ```
        require.config 导入模块是全局都可以使用的，比较适合 框架、基础包之类的文件导入
        
        ```
        // vender/multiply.js
        define(['addModule'], function(addModule) {
            'use strict';
            console.log('加载了 multiply 模块');
            console.log(addModule);
            var multiply = function(x, y){
                return x * y;
            }
        
            return {
                multiply: multiply
            }
        });
        ```
        内部其他文件可以直接导入依赖
        
        ```
        // vender/square.js
        define(['./multiply'], function(multiplyModule) {
            'use strict';
            console.log('加载了 square 模块');
            var square = function(x){
                return multiplyModule.multiply(x, x);
            }
        
            return {
                square: square
            }
        });
        ```
        局部依赖导入，其他模块如需该模块的支持，需要重新导入文件
        
        ```
        // vender/add.js
        define(function() {
            'use strict';
            console.log('加载了 add 模块');
            var add = function(x, y){
                return x + y;
            }
        
            return {
                add: add
            }
        });
        ```
        不导入任何模块
        
        ```
        // 加载了 add 模块
        // 加载了 multiply 模块
        // {add: f}
        // 加载了 square 模块
        // 2
        // 9
        ```
    * cmd
        cmd 是 seaJs在推广过程中对模块定义的规范化产出。CMD 规范，其主要内容就是描述如何定义模块，如何导入模块，如何导出模块，只要按照这个规范书写代码，sea.js就能正确的进行解析
        
        ```
        // index.html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>seaJs</title>
        </head>
        <body>
            <script src="https://cdn.bootcss.com/seajs/3.0.3/sea.js"></script>
            <script>
                seajs.use('./vender/main');
            </script>
        </body>
        </html>
        ```
        通过  seajs.use 来加载主模块
        
        ```
        // vender/main.js
        define(function(require, exports, module) {
            'use strict';
            var addModule = require('./add');
            console.log(addModule.add(1, 1));
        
            var squareModule = require('./square');
            console.log(squareModule.square(3))
        });
        ```
        通过 require 来进行导入模块
        
        ```
        // vender/add.js
        define(function(require, exports, module) {
            'use strict';
            console.log('加载了 add 模块');
            var add = function(x, y){
                return x + y;
            }
        
            module.exports = {
                add: add
            }
        });
        ```
        通过  module.exports 来进行导出模块
        
        ```
        // vender/square.js
        define(function(require, exports, module) {
            'use strict';
            console.log('加载了 square 模块');
        
            var multiplyModule = require('./multiply');
        
            var square = function(x){
                return multiplyModule.multiply(x, x);
            }
        
            module.exports = {
                square: square
            }
        });
        
        // vender/multiply.js
        define(function(require, exports, module) {
            'use strict';
            console.log('加载了 multiply 模块');
            var multiply = function(x, y){
                return x * y;
            }
        
            module.exports = {
                multiply: multiply
            }
        });
        ```
        运行结果
        
        ```
        // 加载了 add 模块
        // 2
        // 加载了 square 模块
        // 加载了 multiply 模块
        // 9
        ```
        
        * 由此可见，CDM 推崇依赖就近，AMD 推崇依赖前置。
            对于依赖的模块，AMD是提前执行，CMD是延迟执行
            对于 AMD 的这种提前加载，在技术上是比较好实现的，而对于CMD的这种，延迟执行，暂时还没有闹明白，不知道是否做了语法切割在require 之间进行切割，以一段一段的方式来进行运行
        * AMD 和 CMD 都是用于浏览器端的模块规范，而在服务端 比如node，采用的则是 CommonJs 规范
        * CommonJs 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。
            * AMD 规范 是非同步加载模块，允许指定回调函数。而node 主要用于服务端，模块文件一般都是存在于本地，所以加载起来很快，不用考虑非同步加载的方式，所以commonJs规范比较适用
            * 但是浏览器端，要用服务端加载模块，最好还是采用非同步模块，因此浏览器端一般采用 AMD 规范
    * Es6模块
        通过script 加载主模块，指定 type 为 module 告诉浏览器这是es6 模块加载
        
        ```
        // index.html
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="X-UA-Compatible" content="ie=edge">
            <title>es6 module</title>
        </head>
        <body>
            <script src="./vender/main.js" type="module"></script>
        </body>
        </html>
        ```
        通过  import   加载模块
        
        ```
        // vender/main.js
        import { add } from './add.js';
        
        console.log( add(1, 1) );
        
        import { square } from './square.js';
        
        console.log( square(3) );
        ```
        
        通过 export 导出模块
        
        ```
        // vender/add.js
        console.log('加载了 add 模块');
        
        var add = function(x, y){
            return x + y;
        }
        
        export {
            add
        }

        // vender/square.js
        console.log('加载了 square 模块');
        
        import { multiply } from './multiply.js';
        
        var square = function(x){
            return multiply(x, x);
        }
        
        export {
            square
        }

        // vender/multiply.js
        console.log('加载了 multiply 模块');
        
        var multiply = function(x, y){
            return x * y;
        }
        
        export {
            multiply
        }
        ```
        运行结果
        
        ```
        // 加载了 add 模块
        // 加载了 multiply 模块
        // 加载了 square 模块
        // 2
        // 9
        ```
        由此可见，es6的模块加载 跟 require 加载一样，都是 非同步加载模式，在所有的依赖加载完成后才会去进行执行

* [前端安全系列（一）：如何防止XSS攻击？](https://tech.meituan.com/fe_security.html)
    * 我们很难完全避免xss，但是我们通过 减少漏洞的产生
        * 利用模板引擎：开启模板引擎自带的html转义功能
        * 避免内联事件：尽量不要 onLoad=“onload(‘{{data}}’)" 这种拼接内联事件的写法。在js通过 addEventlistener 的事件绑定会更安全
        * 避免拼接 html：最好采用  createElement、setAttribute 方法实现，或者 采用 比较成熟的渲染框架  如 Vue/React等
        * 时刻保持警惕：在插入位置为dom属性、链接等位置时，要打起精神，严加防范
        * 增加攻击难度、降低攻击后果：通过csp、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果
        * 主动检测和发现：可使用xss攻击字符串和自动扫描工具寻找潜在的xss漏洞
    * 在css、html 中 使用webpack中定义的别名 ~ 需要加上这个符号，告诉webpack 我使用的是别名
    

### 2018-11-13
* [谈一谈flex布局使用中碰到的一些问题](https://www.jqhtml.com/18730.html)
    * flex单值、双值、三值的赋值规则是怎么样的
    * flex-grow 定义弹性项目的放大比列，可以接受数字（小数也可以），不接受负值，默认值是 0 。这个值如果为 0 就意味着即使容器内还存在剩余空间，弹性项目也不会放大。
    * flex-shrink 定义弹性项目的收缩比例，同样接受数字（小数也可以），不接受负值，默认值是 1 。如果一个弹性项目的 flex-shrink 设为 0 而其他弹性项目的 flex-shrink 值为 1 ，则当弹性容器空间不足时，该弹性项目不会被压缩，而其他的弹性项目会被等比例压缩。
    * flex-basis 定义在分配容器内空间之前，弹性项目占据的主轴空间（不一定是宽度，因为主轴方向可以是纵向的），默认值是 auto 。如果对弹性项目同时设置 flex-basis 和 width ， width 会被忽略。还要注意当主轴是横向的时候，如果设定了 max-width 或 min-width 会限制弹性项目的宽度。
    * 单值情况下：
        * 一个无单位的数字：它会被当作 flex-grow 的值，flex-shrink 为 1 ，flex-basis 为 0%。
        * 一个有效的宽度值：它会被当作 flex-basis 的值，flex-shrink 和 flex-grow 都是 1 。
        * 关键字：比如 auto，none 这两个下文会讲。
    * 双值情况下：
        * 第一个值必须是无单位的数字，它会作为 flex-grow 的值；第二个值可以是：
            * 一个无单位的数字：它会被当作 flex-shrink 的值，而flex-basis 的值就是 0% 。
            * 一个有效的宽度值：它会被当作 flex-basis 的值，flex-shrink 的取值就是 1 。
    * 三值情况下：
        * 第一个和第二个值必须是无单位的数，分别作为 flex-grow，flex-shrink，flex-basis 的值；第三个值可以是有效的宽度值，也可以是 auto 。

    * flex: 0，flex: 1，flex: auto，flex: none，flex: 0%的区别是什么？
        * flex: 0 是 flex: 0 1 0%  的简写
        * flex: none 是 flex: 0 0 auto 的简写
        * flex: 1 是 flex: 1 1 0% 的简写
        * flex: auto 是 flex: 1 1 auto 的简写
        * flex: 0% 是 flex: 1 1 0% 的简写

### 2018-11-12

* 日常总结
    * 当我们需要进行中文排序的时候可以使用
    `['向第三方', '爱仕达多'].sort((a, b) => a.localeCompare(b, 'zh')); // 排序格式 数字 > 拼音 > 字母`
* [JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)
    * 函数式编程中的  of 方法，并不是用来避免使用 new 关键字的，而是用来把值放到默认最小化上下文中的

        ```
        let Container = function(x){
            this.__value = x;
        }
        Container.of = x => new Container(x);
    
        Container.prototype.map = function(f){
            return Container.of(f(this.__value))
        }
        ```
    * 在日常的开发中，我们可以使用 curry 来进行 多参数的函数封装

        ```
        // 仿lodash的curry
        const curry = function(fx){
            var arity = fx.length;
    
            return function f1() {
                var args = Array.prototype.slice.call(arguments, 0);
                if (args.length >= arity) {
                    return fx.apply(null, args);
                } else {
                    var f2 = function f2() {
                        var args2 = Array.prototype.slice.call(arguments, 0);
                        return f1.apply(null, args.concat(args2)); 
                    }
                    f2.toString = function() {
                        return inspectFn(fx) + inspectArgs(args);
                    }
                    return f2;
                }
            };
        }
        ```
* [ES2018（ES9） 带来的重大新特性](https://juejin.im/entry/5be2243451882516c713cda4)
    * defineProperty，可以在一个对象上定义一个新属性，或者修改一个现有属性，并返回这个现有对象。vue2.x 主要是它来进行 数据双向数据绑定、依赖搜集，Object.defineProperty(obj, key, {****}) 
    * defineProperty 中，vlaue 和 get 方法不可同时出现
        * 所以在这里就引发出了一个问题，value的存储和获取的问题。需要去做额外的开销来进行存储。也可以理解为一个数据仓库，需要缓存  value、get方法、set方法
        * 解决方案：
        * 使用 Object.getOwnPropertyDescriptor 来进行读取默认配置

        ```
        (function(){
            var root = this;
            function watch(obj, key, func){
                // 读取配置
                let property = Object.getOwnPropertyDescriptor(obj, key);
                console.log(property);
    
                let value
    
                // 如果属性值不能修改，直接返回
                if(property && property.configurable === false){ return }
    
                let getter = property && property.get,
                    setter = property && property.set;
                
                if(!getter || setter){
                    value = property[key];
                }
    
                Object.defineProperty(obj, key, {
                    get(){
                        let val = getter ? getter.call(obj) : value;
                        return val
                    },
                    set(newValue){
                        let val = getter ? getter.call(obj) : value;
                        // 如果值没有改变，或者 自身不等于自身 直接返回
                        if(val === newValue || (newValue !== newValue && val !== val)){ return }
    
                        setter ? setter.call(obj, newValue) : value = newValue;
                        func(newValue);
                    }
                });
    
                if(value) obj[key] = value;
            }
            this.watch = watch;
        })();
    
        var obj = { name: 'the lonelt' };
        watch(obj, 'name', (value) => {
            console.log(value); // special3961
        });
        watch(obj, 'name', (value) => {
            console.log(value); // special3961
        });
        obj.name = 'special3961';
        ```

    * defineProperty 是 es5的方法，es6提供了更加优雅的 proxy，可以重定义更多的行为

        ```
        let proxy = new Proxy({}, {
            get(obj, prop){
                console.log('设置 get 操作', '    操作源: '+JSON.stringify(obj), '    操作者：'+prop); // 设置 set 操作     操作源: {}     操作者：time     值：35
                return obj[prop]
            },
            set(obj, prop, value){
                console.log('设置 set 操作', '    操作源: '+JSON.stringify(obj), '    操作者：'+prop, '    值：'+value); // 设置 get 操作     操作源: {"time":35}     操作者：time
                obj[prop] = value;
            }
        });
    
        proxy.time = 35;
    
        console.log(proxy.time);
        ```
        
        * 除此之外还可以  拦截  apply、call方法、使用 has方法 拦截 in 操作、ownKeys 方法 拦截对象自身属性的读取操作
        * 不过虽然  proxy 很好用，但是 它最大的问题在于 浏览器支持度不够，而且很多效果无法使用 poilyfill来弥补
    * 使用 defineProperty 和 proxy 还是有很大区别的， 当使用 defineProperty，我们修改原来的obj对象就可以触发拦截，而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截。

        ```
        (function(){
            var root = this;
            function watchProxy(obj, key, func){
                let proxt = new Proxy(obj, {
                    get(target, prop){
                        return target[prop]
                    },
                    set(target, prop, value){
                        target[prop] = value;
                        func(value);
                    }
                });
    
                return proxt;
            }
            this.watchProxy = watchProxy;
        })();
    
        var obj1 = { name: 'the lonelt' };
        obj1 = watchProxy(obj1, 'name', (value) => {
            console.log(value); // special3961
        });
        obj1 = watchProxy(obj1, 'name', (value) => {
            console.log(value); // special3961
        });
        obj1.name = 'special3961';
    
        var obj2 = { name: 'the lonelt' };
        var obj3 = watchProxy(obj2, 'name', (value) => {
            console.log(value); // special3961
        });
        obj3.name = 'special3961';
        console.log(obj3); // Proxy {name: "special3961"}
        console.log('obj3.name: '+obj3.name, '    obj2.name: '+obj2.name); // obj3.name: special3961     obj2.name: special3961
        ```
        由此可见，当我们修改源对象的时候，会把2个对象的值都进行了更改，但是我们设置的  事件拦截，修改源对象的时候并不会触发，只有修改 proxy的实例才会触发

    * 可以使用   Object.create(null); 来创建一个  纯对象，绝对的干净
    * JSON.stringify 不仅可以简单的将对象转化为字符串，还可以格式化json输出        JSON.stringify(obj, null, 4)
    * 数组去重，es6 最快的方法    arr => […new Set(arr)];![image](../../../images/3F5058F4-9E20-41C1-8EE1-5B1DE783A063.png)
    * 平铺数组 可以使用  … 展开符 + concat 方法

        ```
        const arr = [11, [22, 33], [44, 55], 66];
        console.log([].concat(...arr)); //=> [11, 22, 33, 44, 55, 66]
    
        function flattenArray(arr){
            let flatten = [].concat(...arr);
            return flatten.some((item) => Array.isArray(item)) ? flattenArray(flatten) : flatten;
        }
    
        let array = [11, [111, [10, 30, [50, 9, 20]]], [22, 33], [44, [55, 66, [77, [88]], 99]]];
        let numberList = flattenArray(array);
        console.log(numberList); // [11, 111, 10, 30, 50, 9, 20, 22, 33, 44, 55, 66, 77, 88, 99]
        ```

        * 不过这种方法 仅仅适合于二维数字，但是可以通过递归 平铺任意维度的嵌套数组


