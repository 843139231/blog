#### ['1', '2', '3'].map(parseInt) what & why ?
    结果：[1, NaN, NaN]

    干嘛的：
        将数组中的字符串转换为数字，并重新返回一个数组
        
    为什么：
        这个问题主要考察 parseInt的用法
        首先数组的map方法回调函数中接收2个参数，item，index，
        而parseInt方法同样是接受2个参数，第一个 是需要转换的String，第二个是转换的基数
        index == 0的时候
            如果字符串以 Ox 或者 OX 开头则为16进制
            如果字符串以 O 开头 则为 8进制
            其他均为 10进制

#### 赋值、浅拷贝和深拷贝的区别？
    赋值
        基本数据类型：赋值，赋值之后两个变量互不影响
        引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，相互之间有影响
        使用场景：
            Object.assign()
            {...Object}
            Array.prototype.slice()
    浅拷贝
        创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。
        如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址
    深拷贝
        深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。
        深拷贝相比于浅拷贝 速度较慢并且花销较大。拷贝前后两个对象互不影响

#### 深拷贝如何实现？
```
// 第一种方式，也是最简单的方式
JSON.parse(JSON.stringify(Object))

// 常规方式
const clone = target => {
    let res
    if(isArray(target)){
        res = []
        target.forEach(value => {
            res.push(clone(value))
        })
    } else if(isObject(target)){
        res = {}
        for(let key in target){
            if(target.hasOwnProperty(key)){
                res[key] = clone(target[key])
            }
        }
    } else {
        res = target
    }
    return res
}
```

#### new 的原理以及如何实现？
    new 创建的实例有2个特性
        访问到构造函数的属性
        访问到原型的属性
```
// 简易的实现方式
function create() {
    // 创建一个空的对象
    var obj = new Object(),
    // 获得构造函数，arguments中去除第一个参数
    Con = [].shift.call(arguments);
    // 链接到原型，obj 可以访问到构造函数原型中的属性
    obj.__proto__ = Con.prototype;
    // 绑定 this 实现继承，obj 可以访问到构造函数中的属性
    var ret = Con.apply(obj, arguments);
    // 优先返回构造函数返回的对象
    return typeof ret === 'object' ? ret : obj;
};
```

#### bind方法有什么作用？
    bind可以指定this
    返回一个函数
    可以传入参数
    可以执行柯里化

#### 跨域有几种解决方案如何实现？
    跨域解决方案：
        jsonp跨域：
            实现比较简单，但是只能实现get一种请求方式
        document.domain + iframe 跨域：
            仅限主域相同，子域不同的跨域应用场景。
            两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
        location.hash + iframe 跨域：
            a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
        window.name + iframe 跨域：
            window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
            通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。
        postMessage跨域：
            postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
                a.） 页面和其打开的新窗口的数据传递
                b.） 多窗口之间消息传递
                c.） 页面与嵌套的iframe消息传递
                d.） 上面三个场景的跨域数据传递
        CORS：
            通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。
        nginx代理跨域：
            nginx配置解决iconfont跨域
            nginx反向代理接口跨域
        nodejs中间件代理跨域：
            node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。
        webSocket 协议跨域：
            WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
            原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

#### cookie在申请下写不进去？
    1、跨域写cookie 页面在 http://a.com 却硬要写  http://b.com 的cookie
    2、不在  https 却想加上  Secure flag 的  cookie
    3、在 子级域 已经拥有了一个  Secure flag 的 cookie，却想要写 顶级域的 同名cookie .admin.a.com 已经存在了 csrftoken，却想 写 .a.com 的 csrftoken cookie


#### this有几种绑定方式，分别是什么，他们的优先级是怎么样的？
    this的绑定方式：
        默认绑定（严格/非严格模式）
            独立函数调用，可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象
            严格模式下，不能将全局对象用于默认绑定，this会绑定到 undefined 。只有函数运行在非严格模式下，默认绑定才能绑定在全局对象。在严格模式下调用函数则不影响绑定
        隐式绑定
            当函数引用有上下文对象时，隐式绑定规则会把函数中的this绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用中起作用
        显式绑定
            通过 call、apply、bind 方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显式绑定
        new绑定
            构造一个对象并把它绑定到 方法调用中的this
        箭头函数绑定
            根据外层（函数或者全局）作用域（词法作用域）来决定this
    优先级
        箭头函数 > new绑定 > 显式绑定 > 隐式绑定 > 默认绑定
    绑定例外
        把 null 或者 undefined 作为 this 的绑定对象传入 call、apply、bind 这些值在调用时会被忽略，实际应用的是默认规则
        间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生

#### 什么是闭包？
    闭包总结起来就是2点：
        是一个函数
        闭包最终还是执行作用域链相关原则来进行查询 变量，而 作用域链是一个 数组，[当前AO，上级AO，.....，全局AO]这样的顺序来进行查找
    其实本质上，任何回调可以被认定为闭包

#### 什么是作用域链？
    作用域链是一个对象列表或者对象链，它保证了变量对象的有序访问
    当访问一个变量时，解释器会首先在当前作用域查找表示符，如果没有找到，就去父级作用域找，知道找到该变量的标识符或者不在父级作用域中，这就是作用域链

#### js常见的内存泄露以及如何避免？
    有4种常见的js内存泄露
        1、意外的全局变量：
            未定义的变量会在全局对象创建一个新变量 (非严格模式下，严格模式下会直接报错)
            另一个意外的全局变量可能是由 this 创建的。( 当this指向的是全局的情况下，this.xxx = 'xxx'; 这样就会创建了一个全局变量 )

            可以使用严格模式  'use strict' 避免意外的全局变量，在 严格模式下，全局方法的 this 会指向 undefined 而不是 window

        2、被遗忘的计时器或回调函数
            这个只能是人肉操作了，在页面销毁或者用不到的时候及时清除定时器
        3、脱离dom的作用
            如果把dom存成字典（json键值对）或者数组，此时，同样的dom元素存在两个引用：一个在dom树中，另一个在字段中。那么将来需要把两个引用都清除
        4、闭包
            闭包的关键是匿名函数可以访问父级作用域的变量

#### js的继承有几种，分别是什么，最常用的是哪几种？
    原型链继承
        优点：
            方便、简单
        缺点：
            引用类型的属性会被所有实例共享
            创建子类型实例时不能给超类型传参
    构造函数继承
        优点：
            在子类构造器内部调用超类构造函数即可解决引用类型值的问题，同时还能向超类传参
        缺点：
            在超类原型中定义的方法，对子类是不可见的
    组合继承 构造函数继承 + 原型链继承
        融合原型链继承 和 构造函数继承的优点，是目前js 最常用的继承模式
    Object.create类式继承
        基本用于没必要创建构造函数，只想一个对象和另一个对象保持相似的情况
        不过和原型链模式一样，引用类型的属性会被共享
    原型式继承
        基本用于没必要创建构造函数，只想一个对象和另一个对象保持相似的情况
        不过和原型链模式一样，引用类型的属性会被共享
        es5的 Object.create 的模拟实现
    寄生式继承
        创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。
        跟构造函数模式一样，每次创建对象都会创建一遍方法
        太过于浪费空间
    寄生组合式继承
        组合式继承在使用的时候至少会调用两次超类的构造函数(call一次，new一次)
        寄生组合式继承避免了 new 操作再执行一次构造函数并在子类prototype上添加一些不必要的属性
        被高程推荐为  引用类型最理想的继承范式
    class继承(ES6)
        es6继承很简洁，原理 是  es5的原型链继承的语法糖，一样拥有 原型链继承的缺点，就是方便点而已
    
    目前最常用的就是 组合继承以及寄生组合继承

#### 在js中有变量提升这一说法，那么变量和函数的提升哪个的优先级更高呢？
    函数 > 变量

    结论：
        全局上下文的变量对象初始化是全局对象
        函数上下文的变量对象初始化只包括Arguments对象
        在进入执行上下文时会给变量对象添加形参、函数声明、变量声明 等初始的属性值
        在代码执行阶段，会再次修改变量对象的属性值

#### csrf是什么，如何防止？
    CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
    防范策略：
        同源检测，检测Origin Header 以及 Referer Header 来进行判断
        csrf token，可以在请求参数中追加一个 token的校验

#### 如何防止xss攻击？
    我们很难完全避免xss，但是我们通过 减少漏洞的产生
        利用模板引擎：开启模板引擎自带的html转义功能
        避免内联事件：尽量不要 onLoad=“onload(‘{{data}}’)" 这种拼接内联事件的写法。在js通过 addEventlistener 的事件绑定会更安全
        避免拼接 html：最好采用  createElement、setAttribute 方法实现，或者 采用 比较成熟的渲染框架  如 Vue/React等
        时刻保持警惕：在插入位置为dom属性、链接等位置时，要打起精神，严加防范
        增加攻击难度、降低攻击后果：通过csp、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果
        主动检测和发现：可使用xss攻击字符串和自动扫描工具寻找潜在的xss漏洞